Package jah ;

Helpers
	/* BASICOS */
	digitos = ['0' .. '9'];
	letras = ['a' .. 'z'] | ['A' .. 'Z'];
	
	/* CARACTERES ESPECIAIS */
	aspasimples	= ''';
	aspadupla	= '"';
	underline	= '_';
	virgula		= ',';

	/* QUEBRA DE LINHA */
	tab = 9;
	cr = 13;
	lf = 10;
	nl = (cr lf | cr | lf);
	branco = (' ' | '	')+;
	
	/* PARA COMBINACOES */
	menorque	='<';
	maiorque	='>';
	iguala		='=';
	e			='e';
	ou			='ou';
	nao			='nao';
	doispontos	= ':';
	val_bool 	= 'verdadeiro' | 'falso';	
	
Tokens
	
	/* PALAVRAS RESERVADAS DO PROGRAMA */
	programa 	= 'programa';
	inicio 		= 'inicio';
	fim 		= 'fim';
	fim_programa= 'fim.';
	leia 		= 'leia';
	escreva 	= 'escreva';
	constante 	= 'const';
	faca		= 'faca';
	ate			= 'ate';
	de 			= 'de';
	passo		= 'passo';
	senao		= 'senao';
	entao		= 'entao';
	
	/* EXPRESSOES CONDICIONAIS */
	se 		= 'se';
	caso 	= 'caso';
	avalie 	= 'avalie';
	
	/* LOOPS */
	enquanto= 'enquanto';
	para 	= 'para';
	repita	= 'repita';
	fim_para= 'fim para';
	fim_se  = 'fim se';
	
	/* OPERADORES ARITMETICOS */
	soma 	= '+';
	sub 	= '-';
	mult 	= '*';
	div 	= '/';
	
	/* OPERADORES RELACIONAIS */
	maior 		= maiorque;
	menor 		= menorque;
	igual 		= iguala;
	maior_igual = maiorque iguala;
	menor_igual = menorque iguala;
	diferente	= menorque maiorque;
	
	/* OPERADORES BOOLEANOS */
	nao = 'nao';
	e	= 'e';
	ou 	= 'ou';
	xor	= 'xor';
		
	/* TIPOS */
	tipo_inteiro	= 'inteiro';
	tipo_real		= 'real';
	tipo_string		= 'caractere';
	tipo_booleano	= 'booleano';
	
	/* OUTROS TOKENS */
	virgula				= virgula;
	ponto				= '.';
	ponto_virgula		= ';';
	dois_pontos			= doispontos;
	abre_parentesis		= '(';
	fecha_parentesis	= ')';
	abre_colchetes		= '[';
	fecha_colchetes		= ']';
	atribuicao			= doispontos iguala;
	aspas_simples		= aspasimples;
	aspas_duplas		= aspadupla;
	nova_linha			= nl;
	tab					= '	';
	espaco				= ' ';
	
	/* ID E VALORES */
	inteiro	= digitos+;
	real	= digitos+ virgula digitos+;
	string	= aspasimples (letras | digitos | branco)+ aspasimples;
	booleano= val_bool;
	id		= (letras | underline) (letras | underline | digitos)*;

	/* COMENTARIOS */
	comentario_linha = '//';
	comentario_bloco_abre = '/*';	
	comentario_bloco_fecha = '*/';

Ignored Tokens
	tab, espaco, nova_linha;

Productions

	prg {-> prg}
		= programa [id]:id inicio [decl_list]:decl_list [cmd_list]:cmd_list
			{-> New prg(id,decl_list,cmd_list)}
		;
		
	decl_list {-> decl_list}
		= {simples} [decl]:decl	ponto_virgula 						{-> New decl_list.simples(decl)}
		| {multipla} [decl]:decl [decl_list]:decl_list				{-> New decl_list.multipla(decl,decl_list)}
		| {vazia} 
		;
	
	decl {-> decl}
		= {variavel} [tipo]:tipo dois_pontos [var_list]:var_list	{-> New decl.variavel(tipo)}
		| {constante} constante [id]:id [valor]:valor 				{-> New decl.constante(id,valor)}
		;
		
	var_list {-> var_list}
		= {simples} [var]:var										{-> New var_list.simples(var)}
		| {multipla} [var]:var virgula [var_list]:var_list			{-> New var_list.multiplo(var,var_list)}
		;
		
	var {-> var}
		= {normal} [id]:id													{-> New var.normal(id)}
		| {array} [id]:id abre_colchetes [inteiro]:inteiro fecha_colchetes	{-> New var.array(id,inteiro)}
		;
		
	valor {-> valor}
		= {string} string 
		| {inteiro} inteiro 
		| {real} real
		;
		
	tipo {-> tipo}
		= {real} 	tipo_real
		| {inteiro} tipo_inteiro
		| {string}	tipo_string
		;
		
	cmd {-> cmd}
		= {atribuicao} [var]:var atribuicao [exp]:exp ponto_virgula
			{-> New cmd.atribuicao(var,exp)}
		| {leia} leia abre_parentesis [var_list]:var_list fecha_parentesis ponto_virgula
			{-> New cmd.leia(var_list)}
		| {escreva} abre_parentesis [exp]:exp fecha_parentesis ponto_virgula
			{-> New cmd.escreva(exp)}
		| {se} se abre_parentesis [exp_logica]:exp_logica fecha_parentesis entao [cmd_list]:cmd_list fim_se ponto_virgula
			{-> New cmd.se(exp_logica,cmd_list)}
		| {avalie} avalie abre_parentesis [exp]:exp fecha_parentesis
		| {enquanto} enquanto abre_parentesis [exp_logica]:exp_logica fecha_parentesis faca [cmd_list]:cmd_list fim enquanto ponto_virgula
			{-> New cmd.enquanto(exp_logica,cmd_list)}
		| {repita} repita [cmd_list]:cmd_list ate abre_parentesis exp_logica fecha_parentesis ponto_virgula
		
		| {para1} para [var]:var de [int_inicio]:inteiro ate [int_fim]:inteiro faca [cmd_list]:cmd_list fim_para ponto_virgula
			{-> New cmd.para1(var,int_inicio,int_fim,cmd_list)}
		| {para2} para [var]:var de [int_inicio]:inteiro passo [int_passo]:inteiro ate [int_fim]:inteiro faca [cmd_list]:cmd_list fim_para ponto_virgula
			{-> New cmd.para2(var,int_inicio,int_passo,int_fim,cmd_list)}
		;
		
		/*
	exp {-> exp}
		= {valor} 		[valor]:valor 								{-> New exp.valor(valor)}
		| {var} 		[var]:var 									{-> New exp.var(var)}
		| {parentesis} 	abre_parentesis [exp]:exp fecha_parentesis 	{-> New exp.parentesis(exp)}
		| {menos}		sub [exp]:exp 								{-> New exp.menos(exp)}
		| {soma}		[esq]:exp soma [dir]:exp 					{-> New exp.soma(esq,dir)}
		| {sub}			[esq]:exp sub [dir]:exp 					{-> New exp.sub(esq,dir)}
		| {mult}		[esq]:exp mult [dir]:exp 					{-> New exp.mult(esq,dir)}
		| {div}			[esq]:exp div [dir]:exp 					{-> New exp.div(esq,dir)}
		| {logica} 		[exp_logica]:exp_logica 					{-> New exp.logica(exp_logica)}
		;	*/
		
		
	 exp  
	 	= {plus}   exp soma fator  	{-> New exp.soma(exp, fator.exp)  }
        | {minus}  exp sub fator 	{-> New exp.sub(exp, fator.exp) }
        | {factor} fator          	{-> fator.exp}
    	;
    fator {-> exp} 
    	= {mult} fator mult term {-> New exp.mult(fator.exp, term.exp )}
        | {div}  fator div term  {-> New exp.div(fator.exp, term.exp ) }
        | {term} term             {-> term.exp}
   		;

    term {-> exp} 
    	= {valor} valor          {-> New exp.valor(valor)}
        | {parentesis}   abre_parentesis exp fecha_parentesis {-> exp}
        /*| {logica} exp_logica {->New exp.logica(exp_logica)}*/
    	;
 /*   	
    exp_list {-> exp}
    	= {simples} 	[exp]:exp					 {-> New exp_list.simples(exp)}
    	| {multipla}	[exp]:exp virgula [exp_list]:exp_list {-> New exp_list.multipla(exp,exp_list)}
    	; */
	
	exp_logica {-> exp_logica}
		= {parentesis} abre_parentesis [exp_logica]:exp_logica fecha_parentesis {-> New exp_logica.parentesis(exp_logica)}
		| {igual} 		[esq]:exp igual [dir]:exp								{-> New exp_logica.igual(esq,dir)}
		| {diferente} 	[esq]:exp diferente [dir]:exp							{-> New exp_logica.diferente(esq,dir)}
		| {menor_igual} [esq]:exp menor_igual [dir]:exp							{-> New exp_logica.menor_igual(esq,dir)}
		| {maior_igual} [esq]:exp maior_igual [dir]:exp							{-> New exp_logica.maior_igual(esq,dir)}
		| {menor} 		[esq]:exp menor [dir]:exp								{-> New exp_logica.menor(esq,dir)}
		| {maior} 		[esq]:exp maior [dir]:exp								{-> New exp_logica.maior(esq,dir)}
		| {nao} 		nao [exp_logica]:exp_logica								{-> New exp_logica.nao(exp_logica)}
		| {e} 			[esq]:exp_logica e [dir]:exp_logica						{-> New exp_logica.e(esq,dir)}
		| {ou} 			[esq]:exp_logica ou [dir]:exp_logica					{-> New exp_logica.ou(esq,dir)}
		| {xor} 		[esq]:exp_logica xor [dir]:exp_logica					{-> New exp_logica.xor(esq,dir)}
		;

		
	cmd_list {-> cmd_list}
		= {simples}  [cmd]:cmd ponto_virgula							{-> New cmd_list.simples(cmd)}
		| {multipla} [cmd]:cmd ponto_virgula [cmd_list]:cmd_list		{-> New cmd_list.multipla(cmd,cmd_list)}
		;
		
		/*###PAREI NA FAZER DE COMEÇAR A FAZER EXP E EXP_LOGICA*/
		
Abstract Syntax Tree

	prg
		= [id]:id [decl_list]:decl_list [cmd_list]:cmd_list;
		
	decl
		= {variavel} 	[tipo]:tipo
		| {constante} 	[id]:id [valor]:valor
		;
		
	decl_list
		= {simples} [decl]:decl
		| {multipla} [decl]:decl [decl_list]:decl_list
		| {vazia}
		;
	
	valor
		= {string} string 
		| {inteiro} inteiro 
		| {real} real
	;
		
	tipo
		= {real} tipo_real
		| {inteiro} tipo_inteiro
		| {string} tipo_string
		;
	var
		= {normal} id
		| {array} [l]:id [r]:inteiro
		;
		
	var_list
		= {simples} [var]:var
		| {multiplo} [var]:var [var_list]:var_list
		;
		
	cmd_list
		= {simples} [cmd]:cmd
		| {multipla} [cmd]:cmd [cmd_list]:cmd_list
		;
	
	cmd
		= {atribuicao} [var]:var [exp]:exp
		| {leia} [var_list]:var_list
		| {escreva} [exp]:exp
		| {se} [exp_logica]:exp_logica [cmd_list]:cmd_list
		| {para1} [var]:var [int_inicio]:inteiro [int_fim]:inteiro [cmd_list]:cmd_list
		| {para2} [var]:var [int_inicio]:inteiro [int_passo]:inteiro [int_fim]:inteiro [cmd_list]:cmd_list
	;
		
	exp_list
		= {simples} [exp]:exp
		| {multipla} [exp]:exp [exp_list]:exp_list
	;
		
	exp
		= {valor} [valor]:valor
		| {var} [var]:var
		| {parentesis} [exp]:exp
		| {menos} [exp]:exp
		| {soma} [esq]:exp [dir]:exp
		| {sub} [esq]:exp [dir]:exp
		| {mult} [esq]:exp [dir]:exp
		| {div} [esq]:exp [dir]:exp
		| {logica} [exp_logica]:exp_logica
	;
		
	exp_logica
		= {parentesis} [exp_logica]:exp_logica
		| {igual} [esq]:exp [dir]:exp
		| {diferente} [esq]:exp [dir]:exp
		| {menor_igual} [esq]:exp [dir]:exp
		| {maior_igual} [esq]:exp [dir]:exp
		| {menor} [esq]:exp [dir]:exp
		| {maior} [esq]:exp [dir]:exp
		| {nao} [exp_logica]:exp_logica
		| {e} [esq]:exp_logica [dir]:exp_logica
		| {ou} [esq]:exp_logica [dir]:exp_logica
		| {xor} [esq]:exp_logica [dir]:exp_logica
	;
	